package com.olinsdepot.mbus_srvc;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;

import java.net.Socket;
import java.nio.ByteBuffer;

import java.util.Arrays;
import java.util.Timer;
import java.util.TimerTask;

import android.util.Log;
import android.util.SparseArray;

import android.os.Handler;
import android.os.HandlerThread;
import android.os.Looper;
import android.os.Message;
import android.os.Messenger;
import android.os.Process;


/**
 * CommsThread opens a socket on the remote MorBus server and sets up receive and transmit
 * threads to communicate with the server over the LAN. Commands passed down from the MorBus
 * service are wrapped as EmCAN stream commands and sent to the server. The server responses
 * are parsed and resulting events generated are passed up to the MorBus service layer.
 * 
 * @author mhughes
 *
 */
public class CommsThread extends Thread {
	private final String TAG = getClass().getSimpleName();
	private static final boolean L = true;

	/**
	 * Commands supported by Comms thread
	 */
	public static enum CommsCmd {
		SND_STREAM,
		SND_BCST,
		SND_PORT,
		CLOSE,
		UNKNOWN;
		
		/* Returns the code for this Comms command. */
		public int toCode() {
			return this.ordinal();
		}
		
		/* Returns the Comms command for the code passed. */
		public static CommsCmd fromCode(int indx) {
			if(indx < CommsCmd.UNKNOWN.ordinal()) {
				return CommsCmd.values()[indx];
			} else {
				return CommsCmd.UNKNOWN;
			}
		}
	}
	
	/**
	 * Events generated by Comms Thread
	 */
	public static enum CommsEvt {
		START,
		STOP,
		CONNECT,
		UNKNOWN;
		
		/* Returns the code for this Comms event */
		public int toCode() {
			return this.ordinal();
		}
		
		/* Returns the Comms Event for the code passed. */
		public static CommsEvt fromCode(int indx) {
			if(indx < CommsEvt.UNKNOWN.ordinal()) {
				return CommsEvt.values()[indx];
			} else {
				return CommsEvt.UNKNOWN;
			}
		}
	}
	
	/*
	 * Network connection to the remote MorBus server.
	 */
	private final Socket mSocket;
	private final InputStream inputStream;
	private final OutputStream outputStream;
	
	/*
	 * Thread to handle commands from the Morbus Service. It receives
	 * messages from the MorBus service and sends packets to the remote server
	 * via the LAN.
	 */
	private HandlerThread mCommsSendThread;
	private Looper mCommsSendLooper;
	private Handler mCommsSendHandler;
	private Messenger mCommsFmSrvcMsgr;

	/* 
	 * Keep alive thread
	 */
	private static final int UPDATE_INTERVAL = 50000;
	private Timer keepLiveTimer = new Timer();

	/*
	 *  Server state shared with the send and receive threads
	 */
	private static enum SrvrStates {
		INIT,	/* Not connected to server yet */
		READY,	/* Connected, accepting commands. */
		BUSY,	/* Connected, waiting for a command to complete. */
		STOP	/* In process of shutting down. */
	}
	
	/**
	 * Synchronize the server state between the transmit and receive threads.
	 */
	private  class SrvrState {
		
		private SrvrStates myState;
		private Object lock = new Object();
		
		/* Constructor */
		public SrvrState () {
			this.myState = SrvrStates.INIT;
		}
		
		/* Set current Comms state and notify change. */
		private void set(SrvrStates state) {
			synchronized (lock) {
				this.myState = state;
				lock.notify();
			}
		}
		
		/* Test current Comms state. */
		private boolean is(SrvrStates test) {
			synchronized (lock) {
				return (test == this.myState);
			}
		}
		
		/* COMMS is busy */
		private void setBusy() throws InterruptedException {
			synchronized (lock) {
				while (this.myState != SrvrStates.READY) {
					lock.wait();
				}
				
				this.myState = SrvrStates.BUSY;
			}
		}
	}
	
	private SrvrState mSrvrState;
	
	/*
	 * Various EmCAN commands and responses.
	 */
	
	/**
	 * EMCAN stream op codes.
	 */
	private static enum EmCanCmd {
		NOP 		(0),
		PING 		(1),
		ID 			(2),
		FWINFO		(3),
		CMDS		(4),
		RESET		(5),
		SENDS		(6),
		SENDE		(7),
		SENDSR		(8),
		SENDER		(9),
		ENUM		(10),
		KEEPALIVE	(11),
		STROUT		(12);
		
		/* Constructor */
		private final int opcode;		
		private EmCanCmd(int op) {
			this.opcode = op;
		}
		
		/* Returns the code for this EmCAN command */
		public byte toCode() {
			return (byte) this.opcode;
		}
	}

	/**
	 * EMCAN Stream response codes
	 */
	private static enum EmCanRsp {
		EOF			(-1),
		NOP			(0),
		PONG		(1),
		ID			(2),
		FWINFO		(3),
		CMDS		(4),
		CANFR		(5),
		RESET		(6),
		ADR			(7),
		UNADR		(8),
		STROUT		(9),
		STRINRES	(10),
		STRIN		(11),
		UNKNOWN		(255);
		
		/* Constructor */
		private final int rspcode;
		private EmCanRsp(int rsp) {
			this.rspcode = rsp;
		}

		/* Create map of values to Enum */
		private static final SparseArray<EmCanRsp> codeToEnum = new SparseArray<EmCanRsp>();
		static {
			for (EmCanRsp rsp : values()) {
				codeToEnum.put(rsp.toCode(), rsp);				
			}
		}
		
		/* Returns the code for this EmCAN response. */
		public int toCode() {
			return this.rspcode;
		}
		
		/* Returns EmCAN response for the code passed, or UNKNOWN if code is invalid */
		public static EmCanRsp fromCode(int rsp) {
			EmCanRsp retval = codeToEnum.get(rsp);
			if(retval != null) {
				return retval;
			} else {
				return EmCanRsp.UNKNOWN;
			}
		}
	}
	
	/**
	 * Standard Frame Opcodes
	 */
	private static enum StndFrmOp {
		RESET		(0),
		ADRASSIGN	(8),
		SYNC		(12),
		ADRELEASE	(13),
		ADRREQ		(14),
		ADRREQRES	(15);
		
		/* Constructor */
		private final int stdidop;
		private StndFrmOp(int op) {
			this.stdidop = op;
		}
		
		/* Returns the op code for this EmCAN extended frame operation */
		public int toCode() {
			return this.stdidop;
		}
	}
	
	/**
	 * Extended Frame Opcodes
	 */
	private static enum ExtdFrmOp {
		PORTWR		(992),
		PORTRD		(993),
		FWINFO		(1008),
		APPROLE		(1009),
		CONFIG		(1011),
		NPORTS		(1012),
		PORTYPE		(1013),
		PORTSCALE	(1014),
		PORTOFS		(1015),
		SETROLE		(1018),
		PORTINIT	(1019),
		PORTCFG		(1020),
		PORTROLE	(1021),
		STROUT		(1022),
		STRIN		(1023);
		
		/* Constructor */
		private final int extidop;
		private ExtdFrmOp(int op) {
			this.extidop = op;
		}
		
		/* Returns the op code for this EmCAN  extended operation */
		public int toCode() {
			return this.extidop;
		}
	}
	
	
	/**
	 * EmCAN ID field bit definitions
	 */
	private static enum ExtdFrmFlg {
		NEW_DATA			(1 << 16),
		UNSOLICITED			(1 << 15),
		ACK_REQSTD			(1 << 14),
		CONTINUATION		(1 << 13),
		TO_BE_CONTINUED		(1 << 12);
		
		/* Constructor */
		private final int idflgs;
		private ExtdFrmFlg(int flg) {
			this.idflgs = flg;
		}
		
		/* Returns the flag */
		public int toCode() {
			return this.idflgs;
		}
	}
	
	
	/**
	 * Comms Thread constructor: Opens stream and starts transmit thread
	 * 
	 * @param sock - socket of target server.
	 */
	public CommsThread(Socket sock) {
		if (L) Log.i(TAG,"Starting Comms Receive Thread");
		
		/* Init Comms thread state */
		this.setName("SrvrMsgRcv");
		mSrvrState= new SrvrState();;

		mSocket = sock;
		InputStream tmpIn = null;
		OutputStream tmpOut = null;

		/* create input and output stream objects to read and write socket. */
		try {
			tmpIn = mSocket.getInputStream();
			tmpOut = mSocket.getOutputStream();
		}
		catch (IOException e) {
			Log.d(TAG, e.getLocalizedMessage());
		}
		inputStream = tmpIn;
		outputStream = tmpOut;
		
		/* Start the thread to handle messages from MbusService and send to the server */
		mCommsSendThread = new HandlerThread("SrvrMsgSnd", Process.THREAD_PRIORITY_BACKGROUND);
		mCommsSendThread.start();
		mCommsSendLooper = mCommsSendThread.getLooper();
		mCommsSendHandler = new CommsSendHandler(mCommsSendLooper);
		mCommsFmSrvcMsgr = new Messenger(mCommsSendHandler);


		/* Send "START" event to Morbus service with the Comm thread's message handler. */
		Message msg = MbusService.mSrvcFmCommsHandler.obtainMessage();
		msg.what = CommsEvt.START.toCode();
		msg.replyTo  = mCommsFmSrvcMsgr;
        MbusService.mSrvcFmCommsHandler.sendMessage(msg);
	}
	

	/**
	 * Comms Receive Thread: Parses packet from server and generates
	 * events to the Morbus Service.
	 */
	public void run() {
		String TAG = "CommsRcv";
		final byte[] PROT_NAME = {'E','m','C','a','n',':','M','o','r','B','u','s'};
		int protVersion = 0;

		byte rspCode = 0;					/* Byte read from server. */
		byte[] rcvBuf = new byte[1024];		/* buffer store for the stream. */
		int bytes = 0;		                /* number of bytes returned from read. */
		
		while(true) {
			/* Make a blocking call to read response code from input stream. */
			try {
				rspCode = (byte)inputStream.read();				
			}
			catch (IOException e) {
				Log.d(TAG, e.getLocalizedMessage());
				//TODO Send message to service that read on socket failed.
			}
			

			/* Dispatch received server response. */
			switch (EmCanRsp.fromCode(rspCode)) {
			
			case EOF:
				/* Indicates attempt to read a closed socket. */
				if (L) Log.i(TAG, "Reached EOF");
				break;
			
			case NOP:
				/* We ignore NOP except to log it if logging enabled. */
				if (L) Log.i(TAG, "Received NOP");
				break;
			
			case PONG:
				/* If server was BUSY, receiving PONG indicates it's now READY. */
				if (L) Log.i(TAG, "Received PONG");
				if (mSrvrState.is(SrvrStates.BUSY)) {
					mSrvrState.set(SrvrStates.READY);
				}
				break;
			
			case ID:
				/* If state is INIT, ID says server connected. Otherwise, ignored. */
				if (L) Log.i(TAG, "Received ID");
				if (mSrvrState.is(SrvrStates.INIT)) {
					/*Read rest of the ID response... */
					for (bytes = 0; bytes < 1024; bytes++) {
						try {
							rcvBuf[bytes] = (byte)inputStream.read();
						} catch (IOException e) {
							Log.d(TAG, e.getLocalizedMessage());
						}
						if (rcvBuf[bytes] == 0) break;
					}
					
					/*  ...and verify isequal EmCan:Morbus */
					byte[] rcvdId = Arrays.copyOf(rcvBuf,bytes);
					if (Arrays.equals(rcvdId, PROT_NAME)) {
							
						/* Read the protocol version. */
						try {
							protVersion = inputStream.read();
						} catch (IOException e) {
							Log.d(TAG, e.getLocalizedMessage());
						}
	
						/* Send "Connect" event to Morbus service. Attach the server's message handler. */
						Message msg = MbusService.mSrvcFmCommsHandler.obtainMessage();
						msg.what = CommsEvt.CONNECT.toCode();
						msg.arg1 = protVersion; // Report protocol version.
		                MbusService.mSrvcFmCommsHandler.sendMessage(msg);
		                
		                /* Update server state to "Connected, ready for commands" */
			            mSrvrState.set(SrvrStates.READY);

		                //Start a thread to send keep alive commands every 50 seconds
						KeepAliveThread();
					} else {
						/* ID returned did not match. */
						//TODO Respond with a Stop and shutdown.
					}
				}
				break;
			
			case FWINFO:
				if (L) Log.i(TAG, "Received FWINFO");
				break;
			
			case CMDS:
				if (L) Log.i(TAG, "Received CMDS");
				break;
			
			case CANFR:
				if (L) Log.i(TAG, "Received CANFR");
				break;
			
			case RESET:
				if (L) Log.i(TAG, "Received RESET");
				break;
			
			case ADR:
				if (L) Log.i(TAG, "Received ADR");
				break;
			
			case UNADR:
				if (L) Log.i(TAG, "Received UNADR");
				break;
			
			case STROUT:
				if (L) Log.i(TAG, "Received STROUT");
				break;
			
			case STRINRES:
				if (L) Log.i(TAG, "Received STRINRES");
				break;

			case STRIN:
				if (L) Log.i(TAG, "Received STRIN");
				break;

			default:
				Log.d(TAG,"Unknown EMCan response");
				break;
				
			}	/* end switch */
			
			//TODO If we get to here with a state of STOP end the thread.
		}	/* end while */
	}

	/**
	 *  Comms Send Thread: Parses command from service and generates a
	 *  packet to send to the server.
	 *  @param msg - Message from Main containing an MBus event.
	 */
	private final class CommsSendHandler extends Handler {
		
		private ByteBuffer sndBuf;
		private byte[] datBuf;
		
		/* Constructor */
		public CommsSendHandler(Looper looper) {
			super(looper);
		}
		
		/* Message handler */
		@Override
		public void handleMessage(Message msg) {
			if (L) Log.i("CommsSendHandler", "Message type " + msg.what);
			
			/* Dispatch this send command */
			switch (CommsCmd.fromCode(msg.what)) {
			
			case SND_STREAM:
				/* Send the Byte Stream Protocol opcode byte passed in ARG1. */
				sndBuf = ByteBuffer.allocate(1);
				sndBuf.put((byte)msg.arg1);
				write(sndBuf.array());
				break;

			case SND_BCST:
				/* Send a broadcast extended EmCAN frame with ARG1 = opcode, OBJ = data. */
				datBuf = (byte[]) msg.obj;
				// TODO add check on length of datBuf.
				sndBuf = ByteBuffer.allocate(6 + datBuf.length);
				
				/* Build the EmCAN frame. */
				sndBuf.put(EmCanCmd.SENDE.toCode());	/* stream command */
				sndBuf.put((byte) datBuf.length);		/* # of CAN data bytes */
				sndBuf.putInt(getExID(msg.arg1, 0));		/* generate EmCAN ID */
				sndBuf.put(datBuf);						/* CAN data */

				write(sndBuf.array());

				break;
			
			/* Send a port specific EmCAN frame with ARG1 = opcode, ARG2 = node, OBJ = data. */
			case SND_PORT:
				break;
				
			/* Close the socket. */
			case CLOSE:
				cancel();
				break;
				
			default:
				Log.d("CommsSendHandler", "Unknown MBus event type " + msg.what);
				break;
			}  /* switch(CommsCmd) */
		}
	}


	/**
	 * CommsThread Write Method
	 * Write a string of bytes to the output stream.
	 * 
	 * @param bytes - byte array to send
	 */
	private void write(byte[] bytes)
	{
		/* Wait for server state to be READY then set state to BUSY. */
		try {
			mSrvrState.setBusy();
		} catch (InterruptedException e) {
			Log.d(TAG, e.getLocalizedMessage());
		}

		try {
			outputStream.write(bytes);
		} catch (IOException e) {
			Log.d(TAG, e.getLocalizedMessage());
			//TODO Send message to service that write on socket failed.
		}
		
		/* Send PING. Server is ready for next command when it replies PONG. */
		try {
			outputStream.write(EmCanCmd.PING.toCode());
		} catch (IOException e) {
			Log.d(TAG, e.getLocalizedMessage());
		}
	}


	/**
	 * CommsThread Cancel Method
	 * Close the socket
	 */
	private void cancel()
	{
		try {
			mSocket.close();
		}
		catch (IOException e) {
			Log.d(TAG, e.getLocalizedMessage());
		}
	}
	
	/**
	 * Return a 32 bit integer containing the 32 bit extended ID
	 * for an EmCAN external stream frame.
	 */
	private int getExID(int op, int node) {
		int emcanId = 0;
		// TODO right now, only supports broadcast.
		
		if (node == 0) {
			emcanId |= (op << 19);
			emcanId |= ExtdFrmFlg.NEW_DATA.toCode();
		}
		
		return emcanId;
	}

	/**
	 * Keep Alive Thread. Sends a keep-alive frame to the server every 50 seconds.
	 */
	private void KeepAliveThread () {
		keepLiveTimer.scheduleAtFixedRate(new TimerTask() {
			public void run() {
				if (L) Log.i("CommsSendHandler", "Sending Keep_alive");
				Message msg = mCommsSendHandler.obtainMessage();
				msg.what = CommsCmd.SND_STREAM.toCode();
				msg.arg1 = EmCanCmd.KEEPALIVE.toCode();
		        mCommsSendHandler.sendMessage(msg);
			}
		}, 0, UPDATE_INTERVAL);
	}
	
	/**
	 * Bytes to Hex String: Utility function
	 * @param Byte array
	 */
	final protected static char[] hexArray = "0123456789ABCDEF".toCharArray();

	public static String bytesToHex(byte[] bytes) {
	    char[] hexChars = new char[bytes.length * 2];

	    for ( int j = 0; j < bytes.length; j++ ) {
	        int v = bytes[j] & 0xFF;
	        hexChars[j * 2] = hexArray[v >>> 4];
	        hexChars[j * 2 + 1] = hexArray[v & 0x0F];
	    }

	    return new String(hexChars);
	}

}
